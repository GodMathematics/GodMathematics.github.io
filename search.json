[{"title":"前言","url":"/2021/12/15/我的第一篇博客文章/","content":"\n```java\nvoid process(int n, String start, String end, String other) {\n   if (n == 1) {\n       System.out.println(\"Move 1 from \" + start + \" to \" + end);\n   } else {\n       process(n - 1, start, other, end);\n       System.out.println(\"Move \" + n + \" from \" + start + \" to \" + end);\n       process(n - 1, other, end, start);\n   }\n}\n```\n","tags":["beautiful"],"categories":["我的文章"]},{"title":"HashMap","url":"/2021/12/15/HashMap源码/","content":"\n## 哈希值不同地址值一定不同证明\n条件1：地址值相同哈希值一定相同\n> i1 = a i2 = b\n哈希函数f(x) 唯一，嵌套后也只会存在关系f(f(f(x)))\nhash1 = f(i1)\nhash2 = f(i2)\n得出条件1: 如果地址值i1 = i2 则hash1 = hash2 这是绝对成立的\n\n假设：哈希值不同地址值相同 --哈希值hash1 != hash2     地址值i1 = 地址值i2\n> 因为 地址值i1 = i2 \n根据条件1 \n可以得出  hash1 = hash2\n与假设   hash1 != hash2 相反\n所以假设不成立\n所以哈希值不同时地址值一定不同\n\n结论：因为假设不成立得出哈希值不同时地址值一定不同\n\n\n\n  -------\n## 关于在HashMap时 put()时 部分操作分析\n源码\n```java\n//put(K key, V value)和putVal(int hash, K key, V value, boolean onlyIfAbsent,\nboolean evict)\n//调用put方法\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n//进入putVal\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\nboolean evict) {//hash: key哈希值 key: 键. vlue: 值\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)//注意这里如果数组tab不为空 就会n = tab.length 获取了数组的长度\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null) //桶地址i = （n-1) & hash这个值相当于hash 和 数组长度取余 这个值一定小于数组长度n。并且取到这个值p = tab[i]\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash && \n                ((k = p.key) == key || (key != null && key.equals(k)))) \n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n```\n-------\n### 重点分析 \n```java\nif (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n```\n这个判断为判断key值是为同一个key，在方法中多次见到；\n\nif (e.hash == hash && ((k = e.key)\n1. 为什么有equls和==还**要**进行hash值判断 和 为什么要**先**进行hash判断 （提高效率）\n    * hash值是成员变量所以通过对象取的非常快。\n    * hash值是int类型，== 比较非常快\n2. 为什么要**先**进行hash判断 （提高效率）\n    * hash值不同地址值一定不同 若所以使用&& 若false则不需要再进行后面的判断\n    * hash值是成员变量所以通过对象取的非常快。\n    * hash值是int类型，== 比较非常快 \n\n(k = e.key) == key || (key != null && key.equals(k)\n1. 为什么要进行有了 == 还要equals判断\n    * 首先其实如果equals不重写 与 == 一致，而当地址值比较并不能作为满足业务**唯一**条件时就需要重写equlas方法\n2. 为什么要用|| （提高效率）\n    * 实际中equals可能是要比== 复杂。所以，当地址值相同时肯定是相同对象，不管equals有没有重写 如果true不需要进行后面判断\n    * 当地址时不同时，就看是否满足因业务需求重写equals，没重写则与==结果一样\n","tags":["java","HashMap"],"categories":["java - HashMap"]}]